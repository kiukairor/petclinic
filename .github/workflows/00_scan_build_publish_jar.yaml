name: Scan, Build and Publish Jar

on:
  push:
    branches: [main]
    paths:
      - 'pom.xml'
      - 'src/**'
      - '.github/workflows/00_scan_build_publish_jar.yaml'

permissions:
  id-token: write
  contents: read
  security-events: write

env:
  BUILD_NAME: ${{ github.workflow }} 
  BUILD_NUMBER: ${{ github.run_number }}  

jobs:
  quality-security-gates:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up jf cli (xray scans)
        uses: jfrog/setup-jfrog-cli@v4
        env:
            JF_URL: https://trial3sr477.jfrog.io 
        with:
            oidc-provider-name: github-jfrog 
            oidc-audience: my-aud
            version: 2.75.0
      
      # I failed to leverage jf CLI to use 'jf mvn' here, as I needed to provide some config and I was not sure how to do it in an automated and elegant way.
      ## Should be studied further to assess if there is a more elegant way to run run maven commands.     
      - name: Generate settings.xml dynamically
        run: |
          mkdir -p ~/.m2
          envsubst < .github/param-settings.xml > ~/.m2/settings.xml
        env:
          ARTIFACTORY_USERNAME: ${{ secrets.ARTIFACTORY_USERNAME }}
          ARTIFACTORY_PASSWORD: ${{ secrets.ARTIFACTORY_PASSWORD }}

      # Non-blocking quality checks.
      ## checkstyle is about code quality.
      ## checkstyle:check could make it blocking.
      - name: Code Quality Checks 1
        run: ./mvnw checkstyle:checkstyle
      ## Spotbugs is a static code analysis tool that looks for bugs in Java programs.
      - name: Code Quality checks 2
        run: ./mvnw spotbugs:check

      # Security Checks -- Failing if too many High vulnerabilities
      ## Note that jfrog watches can do similar things with better control but need the artifacts to be uploaded. If failing defined policies, these artifacts can then be quarantined (See Next step of the workflow).
      ## Here the idea is to avoid building the jar if we detect too many vulnerabilities right away.
      
      - name: Initial security checks
        run: |
          echo "|> Counting vulnerabilities before building and abort if too many... "
          jf audit  --format table --min-severity Medium > table.txt 
          vuln=$(cat table.txt | grep -E 'High|Critical' | tr -d ' ' |wc -l)        

          if [ "$vuln" -gt 10 ]; then
            echo "Static analysis found too many High/Critical vulnerabilities($vuln vulnerabilities)"
            echo "Aborting build workflow..."
            exit 1
          fi
          echo "Static analysis found $vuln High/Critical vulnerabilities. Proceeding with maven build."               

  maven-build-publish: 
    needs: quality-security-gates
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}

      # Same reason as previous step.
      - name: Generate settings.xml dynamically
        run: |
          mkdir -p ~/.m2
          envsubst < .github/param-settings.xml > ~/.m2/settings.xml
        env:
          ARTIFACTORY_USERNAME: ${{ secrets.ARTIFACTORY_USERNAME }}
          ARTIFACTORY_PASSWORD: ${{ secrets.ARTIFACTORY_PASSWORD }}

      
      - name: Clean project
        run: ./mvnw clean

      # More quality checks are includeded here. 
      # As part of maven lifecycle, more checks will be run up to verify (unit test, integarion tests, and some jacoco tests as defined in pom.xml).
      - name: Verify (validate, compile, test, package, verify)
        run: ./mvnw verify
        
      # - name: Check Jar creation  
      #   run: |
      #     echo "Checking if JAR file was created..."
      #     ls -l target/
      #     ls -l
      #     if [ ! -f target/*.jar ]; then
      #       echo "No JAR file found in target directory. Aborting build step."
      #       exit 1
      #     else
      #       echo "JAR file found in target directory."
      #     fi

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-artifact
          path: target/*.jar

# I merged step build and publish to benefit the git commit and build number in the JFrog Artifactory.
  # publish:
  #   runs-on: ubuntu-latest
    # needs: maven-build
    # steps:
    #   - name: Download built artifact
    #     uses: actions/download-artifact@v4
    #     with:
    #       name: app-artifact
    #       path: target/

    



      # - name: check files
      #   run: |
      #     echo "Checking files in target directory..."
      #     ls -l
      #     ls -l target/
      #     if [ ! -f target/*.jar ]; then
      #       echo "No JAR file found in target directory. Aborting publish step."
      #       exit 1
      #     fi    
      # - name: Set up jf cli
      #   uses: jfrog/setup-jfrog-cli@v4
      #   with:
      #     version: 2.75.0
      #     oidc-provider-name: github-jfrog
      #     oidc-audience: my-aud

      - name: Set up JFrog CLI
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: https://trial3sr477.jfrog.io
        with:
          oidc-provider-name: github-jfrog
          oidc-audience: my-aud
      
      - name: Collect environment and git info
        run: |
          jf rt build-collect-env
          jf rt build-add-git    

      - name: Upload to Artifactory  
        run: jf rt upload --url="$JF_URL" "target/*.jar" "my-repo-libs-snapshot-local/" --build-name="$BUILD_NAME" --build-number="$BUILD_NUMBER"

      - name: Publish build info
        run: |
          jf rt build-publish 
          jf bs --format table  --vuln true "$BUILD_NAME" "$BUILD_NUMBER"


## static quality and security inital tests passed.
## Unit tests and integration tests succeeded, as part of maven verify phase passed.
## Jfrog XRay scan passed on Artifactory.
# One could promote the jar.

# In a real life scenario, we would not want to promote a SNAPSHOT version of the jar, we would leverage branching and taggging strategies to ensure that we only promote stable versions of the jar.
# However for the sake of this demo, we will use jf cli to promote this very jar to a dev repository (even if the jar will still embed the SNAPSHOT version).
  promote:
    needs: maven-build-publish
    runs-on: ubuntu-latest
    steps:
      - name: Set up JFrog CLI
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: https://trial3sr477.jfrog.io
        with:
          oidc-provider-name: github-jfrog
          oidc-audience: my-aud
          version: 2.75.0

      - name: Promote the jar to dev repository
        run: |
          jf rt promote --url="$JF_URL" "my-repo-libs-snapshot-local/spring-petclinic-3.5.0-SNAPSHOT.jar" "my-repo-libs-dev-local/" --build-name="$BUILD_NAME" --build-number="$BUILD_NUMBER"